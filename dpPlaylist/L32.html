<!DOCTYPE html>
<html lang="en-US" oncontextmenu="return false">
  <head>
    <title>DPL32 Distinct Subsequences üî•</title>
    <link rel="icon" type="image/x-icon" href="../photo.jpg" />

    <link
      rel="stylesheet"
      id="wp-block-library-css"
      href="https://www.lexalytics.com/wp-includes/css/dist/block-library/style.min.css?ver=6.0.3"
      type="text/css"
      media="all"
    />
    <style id="global-styles-inline-css" type="text/css"></style>

    <link
      rel="stylesheet"
      id="wd_s-css"
      href="https://www.lexalytics.com/wp-content/themes/wd_s/build/index.css?ver=0c4cbca560ded1aeeb10beb9a609f609"
      type="text/css"
      media="all"
    />

    <link rel="stylesheet" href="../style.css" />
  </head>


  <body
    class="page-template-default page page-id-2597 page-child parent-pageid-2342 wp-embed-responsive site-wrapper page-machine-learning group-blog no-js"
  >
    <a class="skip-link screen-reader-text" href="#main">Skip to content</a>

    <div class="site-main">
      <main id="main" class="content-container">
        <article
          id="post-2597"
          class="post-2597 page type-page status-publish hentry"
        >
          <div class="entry-content">
            <div
              id="section-block_627ed6b337646"
              class="block-section relative overflow-hidden 0"
            >
              <div class="bg-white py-100 bg-cover centerbg- bg-no-repeat">
                <div class="relative container-narrow">
                  <h5 class="has-text-align-center">
                    <mark
                      style="background-color: rgba(0, 0, 0, 0)"
                      class="has-inline-color has-nebula-color"
                    >
                      JB TAK FODEGA NHI .... TB TK CHODEGA NHI .... (MAANG)
                    </mark>

                    <br><br>

                    <div class="dsa">
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh1/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh2/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://auth.geeksforgeeks.org/user/itsprince/practice"><img src="../dsaProfileImg/gfg.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codingninjas.com/codestudio/profile/b7191958-3dea-4d59-a909-70a6bd5400c8"><img src="../dsaProfileImg/cn.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.interviewbit.com/profile/princesingh2002"><img src="../dsaProfileImg/ib.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerrank.com/dsawithprince?hr_r=1"><img src="../dsaProfileImg/hr.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerearth.com/@prince1033"><img src="../dsaProfileImg/he.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codechef.com/users/princesingh001"><img src="../dsaProfileImg/cc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://codeforces.com/profile/thisisPrinceSingh"><img src="../dsaProfileImg/cf.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://workat.tech/profile/itsprincesingh"><img src="../dsaProfileImg/wk.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.linkedin.com/in/prince-singh-314a65187/"><img src="../dsaProfileImg/lin.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://github.com/PrinceSinghhub"><img src="../dsaProfileImg/gh.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://twitter.com/NowPrinceSingh"><img src="../dsaProfileImg/tw.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://stackoverflow.com/users/16512708/prince-singh"><img src="../dsaProfileImg/st.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://topmate.io/itsprincesingh"><img src="../dsaProfileImg/topm.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://hashnode.com/@itsPrinceSingh"><img src="../dsaProfileImg/hn.png" alt=""></a></div>
                    </div>
                  </h5>

                  <h1 class="has-text-align-center mb-60">
                    DPL32 Distinct Subsequences üî•
                  </h1>

                  <div class="allBTNGroups">
                  <button class="hardQst" role="button">üò¢ Hard</button>
                  <!-- <button class="mediumQst" role="button">üòü Medium</button> -->
                  <!-- <button class="easyQst" role="button">üòä Easy</button>
                    
                    <button class="hardQst" role="button">üò¢ Hard</button> -->
                  <a href=""><button class="leetcodelink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/leetcode.webp" alt="">LeetCode
                      </div>
                    </button></a>
                  <a href=""><button class="gfgQstlink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/geeksforgeeks.png" alt="">GeeksForGeeks
                      </div>
                    </button></a>
                  <a href=""><button class="codslink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/codeStudio.png" alt="">CodeStudio
                      </div>
                    </button></a>
                </div>

                  <!-- Problem Statements  -->
                  <p>We are given two strings S1 and S2, we want to know how many distinct subsequences of S2 are present in S1.</p>

                  <img src="./Notes/L32expImg.jpg" alt=""> <br>

                  <li>Again this Problem is based on the <b>DP on String</b> in Prevesilly Some problem we solved the Problem using the concept of the <b>Longest Common Subsequence</b></li>
                  <li>Now his portion we moved on the <b>String Matching on DP on String</b></li>
                  <li>Now we solved the 3 Upcomming Problems and this Problmes are based on the <b>DP on String Matchinbg</b> and the Problem Level is <b>LeetCode Hard</b></li>
                  <br>

                  <p>If we Talk about this Typle of Problem then only one things Comes into the Our Mind that is Recursion becouse only the Recursion is the Only Method to Find the all the <b>Possible Ways</b></p>

                  <li>Now in the Recursion Portion we Discuss <b>Lecture 6 and Lecture 7</b> we learned how to the count all the possible Ways</li>
                  <br>
                  <p>This is the Frame of the Recursion that we used in the Recursion Portion</p>
                  <img src="./Notes/L32expImg1.jpg" alt=""> <br>



             
                 <br>
                  <h3>Recursice Approch</h3>

                  <b>Steps to form the Recursive Solution</b> <br>

                  <b>Step 1: Express the problem in terms of indexes.</b><br>

<li>
    We are given two strings. We can represent them with the help of two indexes i and j. Initially, i=n-1 and j=m-1, where n and m are lengths of strings S1 and S2. Initially, we will call f(n-1,j-1), which means the count of all subsequences of string S2[0‚Ä¶m-1] in string S1[0‚Ä¶n-1]. We can generalize it as follows:
</li> <br>

<img src="./Notes/L32resImg1.jpg" alt=""> <br>

<b>Step 2: Try out all possible choices at a given index.</b> <br>

<p>Now, i and j represent two characters from strings S1 and S2 respectively. We want to find distinct subsequences. There are only two options that make sense: either the characters represented matched or Not matched</p>

<b>Case 1: When the characters match</b>

<li>
    <b>if(S1[i]==S2[j])</b> then we have 2 Different-Different Senior Occured
</li>
<p>S1[i] == S2[j], now as the characters at i and j match, we would want to check the possibility of the remaining characters of S2 in S1 therefore we reduce the length of both the strings by 1 and call the function recursively.</p>

<img src="./Notes/L32resImg2.jpg" alt="">
<br>
<p>
    <b>VVVV Important Point</b> <br />
    Now, if we only make the above single recursive call, we are rejecting the opportunities to find more than one subsequences because it can happen that the jth character may match with more characters in S1[0‚Ä¶i-1], for example where there are more occurrences of ‚Äòg‚Äô in S1 from which also an answer needs to be explored.
</p>

<img src="./Notes/L32resImg3.jpg" alt="">

<br>
<p>
    To explore all such possibilities, we make another recursive call in which we reduce the length of the S1 string by 1 but keep the S2 string the same, i.e we call f(i-1,j).
</p>

<img src="./Notes/L32resImg4.jpg" alt="">
<br>

<li>Overall we Can Say that if <b>S1[i] == S2[j] then we have 2 Options that is to Explore the Remaining Porribilities of the occurrences of the <b>Current J</b></b></li>
<li><b>Picked J and Not Picked J</b> function(i-1,j-1) + function(i-1,j)</li>

<br>

<b>Case 2:  When the characters don‚Äôt match</b>

<li>
    <b>if(S1[i] != S2[j])</b>, it means that we don‚Äôt have any other choice than to try the next character of S1 and match it with the current character S2.
</li>
<li>Then Simply call the Recursion Function for the moving into the Nect char of the i and J Constant for math if any Possible Occurance of the Current j is Possible of Not, <b>function(i-1,j)</b></li>
<br>
<img src="./Notes/L32resImg5.jpg" alt="">

<br>
<b>Summarized the both Conditions</b>
<li><b>if(S1[i]==S2[j])</b>, call f(i-1,j-1) and f(i-1,j).</li>
<li><b>if(S1[i]!=S2[j])</b>, call f(i-1,j).</li>
 <br>

<b>Step 3: Return the sum of choices</b> <br>

<li>As we have to return the total count, we will return the sum of f(i-1,j-1) and f(i-1,j) in case 1 and simply return f(i-1,j) in case 2. 
</li>

<br>
<b>Base Cases</b>
<li>if j < 0, it means we have matched all characters of S2 with characters of S1, so we return 1.</li>
<li>if i < 0, it means we have checked all characters of S1 but we are not able to match all characters of S2, therefore we return 0.</li>
<br>
<p>The final pseudocode after steps 1, 2, and 3:</p>
<img src="./Notes/L32resImg6.jpg" alt=""> <br>


        <div class="container">
                    <div class="item">
                      <div class="title"><b>Recursion Python Code</b></div>
                      <div class="content">
                        <img src=".//Notes/L32rocde (1).png" alt="" />
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion C++ Code</b></div>
                      <div class="content">
                        <img src=".//Notes/L32rocde (2).png" alt="" />
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>
                  <br>

                  <h3>Time & Space Complexity</h3>
                  <b>Time Complexity: O(2^N)</b> <br>

Reason: Exponential Time we find out the all the Possible Path<br>

<b>Space Complexity: O(N)</b> <br>

Reason: We are using a recursion stack space(O(N))<br><br>

<h3>Memoization Approch</h3>

<p>
    If we Observe in the recursion tree, we will observe a many number of overlapping subproblems. Therefore the recursive solution can be memoized for to reduce the time complexity.
</p>

<b>Steps to convert Recursive code to memoization solution:</b> <br><br>

<li>Create a dp array of size [n][m]. The size of S1 and S2 are n and m respectively, so the variable i will always lie between ‚Äò0‚Äô and ‚Äòn-1‚Äô and the variable j between ‚Äò0‚Äô and ‚Äòm-1‚Äô.</li> <br>
<li>We initialize the dp array to -1.</li> <br>
<li>Whenever we want to find the answer to particular parameters (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li> <br>
<li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li>
<br>

                  <div class="container">
                    <div class="item">
                      <div class="title"><b>Memoization Python Code</b></div>
                      <div class="content">
                        <img src="./Notes/L32memocode (1).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization C++ Code</b></div>
                      <div class="content">
                        <img src="./Notes/L32memocode (2).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>

                  <br>

                  <h3>Time & Space Complexity</h3>
                  
                    <b>Time Complexity:O(N*M)</b> <br>
                    
                    Reason: There are N*M states therefore at max ‚ÄòN*M‚Äô new problems will be solved.<br>

<b>Space Complexity: O(N*M) + O(N+M)</b> <br>

Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).<br><br>

<h3>Tabulation Approch</h3>

Tabulation is a <b>‚Äòbottom-up‚Äô</b> approach where we start from the base case and reach the final answer that we want and Memoization is the <b>Top-down</b> Approch.
<br>
<p>
    In Tabulation Approch We Just Creat a DP Array Same as Memoization and Simply Convert the <b>Recurance Relation into the form of the Looping</b>
</p>

<b>Steps to convert Recursive Solution to Tabulation one.</b><br>

<li>In the recursive logic, we set the base case too if( i < 0 ) and if( j < 0 ) but we can‚Äôt set the dp array‚Äôs index to -1. Therefore a hack for this issue is to shift every index by 1 towards the right.</li>
<br>
<img src="./Notes/L32tabExp.jpg" alt=""><br>
<li>To convert the memoization approach to a tabulation one, create a dp array with the same size as done in memoization. We can initialize it as 0.</li>
<br>
<li>First, we need to initialize the base conditions of the recursive solution.</li>
<br>
<li>if J == 0 that means we search all the String of the S2 in S1 <b>So we Marked Every j == 0 is 1</b> </li> <br>
<li>if i == 0 that means we something remaining that not found in the S1 <b>So we Marked Every i == 0 is 0</b></li> <br>
<li>Similarly, we will implement the recursive code by keeping in mind the shifting of indexes, therefore S1[i] will be converted to S1[i-1]. Same for S2.</li>
<br>
<img src="./Notes/L32tabExp1.jpg" alt="">
<br>
<li>
    At last, we will print dp[N][M] as our answer.
</li>

<br>
<div class="container">
  <div class="item">
    <div class="title"><b>Tabulation Python Code</b></div>
    <div class="content">
      <img src="./Notes/L32tabcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation C++ Code</b></div>
    <div class="content">
      <img src="./Notes/L32tabcode (2).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity:  O(N*M)</b> <br>

                    Reason:There are 2 nested loops<br>

<b>Space Complexity: O(N*M)</b> <br>

Reason: We are using an external array of size ‚ÄòN*M‚Äô. Stack Space is eliminated.<br><br>

<h3>Space Optimization</h3>

<p>
    If we closelly Observed <b>if any Tabulation Approch we used the Some Limited Stuff like: dp[i][j] =  dp[i-1][j-1] + dp[i-1][j]  or dp[i][j] = dp[i-1][j]</b> for the finding the our ans then definetly here <b>Spaced Optimization</b> is Possible in that types of Problems. <b>Always Remember</b>
</p>

<b>Golden Rule</b>
<li>If we required only Prev row and Prev Collom then definetly we can Space Optimized</li>

<p>

  <li>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev). So, we don‚Äôt need to store an entire array. Hence we can space optimize it.</li> <br>

  <li>We will be space optimizing this solution using <b>only one row</b>.</li> <br>
  <p>
    We have 2 Different Way to Optimized this Problem 
    <li>using 2 array</li>
    <li>using 1 array</li> <br>
    <b>Same like the 0/1 and unbounded Knapsack Problem</b>
  </p>
  <li>If we clearly see the values required:  dp[i-1][j-1] and dp[i-1][j], we can say that if we are at a column j, we will only require the values shown in the grey box from the previous row and other values will be from the cur row itself. So why do we need to store an entire array for it?</li> <br>

  <img src="./Notes/L32spImg.jpg" alt="">
  <br>

  <p>If we need only two values from the prev row, there is no need to store an entire row. We can work a bit smarter.</p>
 
  <b>We can use the cur row itself to store the required value in the following way:</b>
  <li>We take a single row ‚Äòprev‚Äô.</li> <br>
  <li>We initialize it to the base condition.</li> <br>
  <li>Whenever we want to compute a value of the cell prev[j], we take the already existing value (prev[j] before new computation) and prev[j-1] (if required, in case of character match).</li> <br>
  <li>We perform the above step on all the indexes.</li> <br>
  <li>So we see how we can space optimize using a single row itself.</li> <br>
  <li>last our ans is prev[index2]</li>
</p>

<br>
<div class="container">
  <div class="item">
    <div class="title"><b>SpaceOptmized Python Code</b></div>
    <div class="content">
      <img src="./Notes/L32spcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Most Optimial Python Code üî•</b></div>
    <div class="content">
      <img src="./Notes/L32motCode.png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>SpaceOptmized C++ Code</b></div>
    <div class="content">
        <img src="./Notes/L32spcode (2).png" alt="" />
    </div>
  </div>
  

  <div class="item">
    <div class="title"><b>SpaceOptmized Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity: O(N*W)</b> <br>

                    Reason: There are three 2 nested loops<br>

<b>Space Complexity: O(W)</b> <br>

Reason: We are using an external array of size ‚ÄòW+1‚Äô to store only one row.<br><br>

                </div>
                <br />

                <center>~ It's All About Consistencyüìà DedicationüéØ HardWorküí™ Happy Coding‚ù§Ô∏è ~</center>
              </div>
            </div>
          </div>
        </article>
        <!-- #post-## -->
      </main>

      <!-- #main -->
    </div>
    <script src="../script.js"></script>
  </body>
</html>
