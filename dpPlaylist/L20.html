<!DOCTYPE html>
<html lang="en-US" oncontextmenu="return false">
  <head>
    <title>DPL20 Minimum Coins "Infinite Supplies Pattern"</title>
    <link rel="icon" type="image/x-icon" href="../photo.jpg" />

    <link
      rel="stylesheet"
      id="wp-block-library-css"
      href="https://www.lexalytics.com/wp-includes/css/dist/block-library/style.min.css?ver=6.0.3"
      type="text/css"
      media="all"
    />
    <style id="global-styles-inline-css" type="text/css"></style>

    <link
      rel="stylesheet"
      id="wd_s-css"
      href="https://www.lexalytics.com/wp-content/themes/wd_s/build/index.css?ver=0c4cbca560ded1aeeb10beb9a609f609"
      type="text/css"
      media="all"
    />

    <link rel="stylesheet" href="../style.css" />
  </head>


  <body
    class="page-template-default page page-id-2597 page-child parent-pageid-2342 wp-embed-responsive site-wrapper page-machine-learning group-blog no-js"
  >
    <a class="skip-link screen-reader-text" href="#main">Skip to content</a>

    <div class="site-main">
      <main id="main" class="content-container">
        <article
          id="post-2597"
          class="post-2597 page type-page status-publish hentry"
        >
          <div class="entry-content">
            <div
              id="section-block_627ed6b337646"
              class="block-section relative overflow-hidden 0"
            >
              <div class="bg-white py-100 bg-cover centerbg- bg-no-repeat">
                <div class="relative container-narrow">
                  <h5 class="has-text-align-center">
                    <mark
                      style="background-color: rgba(0, 0, 0, 0)"
                      class="has-inline-color has-nebula-color"
                    >
                      JB TAK FODEGA NHI .... TB TK CHODEGA NHI .... (MAANG)
                    </mark>

                    <br><br>

                    <div class="dsa">
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh1/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh2/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://auth.geeksforgeeks.org/user/itsprince/practice"><img src="../dsaProfileImg/gfg.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codingninjas.com/codestudio/profile/b7191958-3dea-4d59-a909-70a6bd5400c8"><img src="../dsaProfileImg/cn.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.interviewbit.com/profile/princesingh2002"><img src="../dsaProfileImg/ib.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerrank.com/dsawithprince?hr_r=1"><img src="../dsaProfileImg/hr.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerearth.com/@prince1033"><img src="../dsaProfileImg/he.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codechef.com/users/princesingh001"><img src="../dsaProfileImg/cc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://codeforces.com/profile/thisisPrinceSingh"><img src="../dsaProfileImg/cf.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://workat.tech/profile/itsprincesingh"><img src="../dsaProfileImg/wk.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.linkedin.com/in/prince-singh-314a65187/"><img src="../dsaProfileImg/lin.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://github.com/PrinceSinghhub"><img src="../dsaProfileImg/gh.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://twitter.com/NowPrinceSingh"><img src="../dsaProfileImg/tw.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://stackoverflow.com/users/16512708/prince-singh"><img src="../dsaProfileImg/st.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://topmate.io/itsprincesingh"><img src="../dsaProfileImg/topm.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://hashnode.com/@itsPrinceSingh"><img src="../dsaProfileImg/hn.png" alt=""></a></div>
                    </div>
                  </h5>

                  <h1 class="has-text-align-center mb-60">
                    DPL20 Minimum Coins "Infinite Supplies Pattern"
                  </h1>

                  <!-- Problem Statements  -->
                  <p>We are given a target sum of ‘X’ and ‘N’ distinct numbers denoting the coin denominations. We need to tell the minimum number of coins required to reach the target sum. We can pick a coin denomination for <b>any number of times</b> we want.</p>

                <img src="./Notes/L20expImg.jpg" alt="" >

                  <b>Why a Greedy Solution doesn’t work?</b>
                  <p>The first approach that comes to our mind is greedy. A greedy solution will fail in this problem because there is no <b>‘Uniformity’</b> in data. While selecting a local better choice we may choose an item that will in long term give less value.</p>

                  <b>Let us understand this with help of an example</b> <br>


                  <img src="./Notes/L20grdImg.jpg" alt="" > <br>

                  <li>Gready Work on the Principle on Best Option on the Every Position</li> 
                  <li>According to the Gready we Want the {9,1,1}. Coins to reach the <b>Taget = 11</b> Ans: 3</li> 
                  <li>But According to the Non-Gready Approch We Want {6,5}. Coins to reach the <b>Taget = 11</b> Ans: 2</li> <br>
                  <li>As the greedy approach doesn’t work, we will try to generate all possible combinations using recursion and select the combination which gives us the minimum number of coins.</li>

                  <br>
                 
                  <h3>Recursice Approch</h3>

                  <b>Steps to form the Recursive Solution</b> <br>

                  <b>Step 1: Express the problem in terms of indexes.</b><br>

<li>
    We are given ‘n’ distinct numbers. Their denomination is represented by the ‘arr’ array. So clearly one parameter will be ‘ind’, i.e index up to which the array items are being considered.<br>

    There is one more parameter “Target”. We need to know the given target that we want to achieve<br>

    So, we can say that initially, we need to find fun(n-1, Target) where T is the initial target given to us. fun(n-1, Target) means we are finding the minimum number of coins required to form the target sum by considering coins from index 0 to n-1.
</li> <br>

<img src="./Notes/L20refun1.jpg" alt="">

<b>Our Base Case</b>
<li>If ind==0, it means we are at the first item, so in that case, the following cases can arise.
</li>
<li><b>arr[0] = 4 and T = 12</b>In such a case where the target is divisible by the coin element (T%arr[0]==0), we will return <b>T // arr[0]</b></li>
<li><b>arr[0] =4 and T=1 , arr[0]=3 T=10</b>In all other cases, we will not be able to form a solution (T%arr[0]!=0), so we will return a big number like <b>1e9</b></li>

<img src="./Notes/L20refun2.jpg" alt="">

<br>
<b>Step 2: Try out all possible choices at a given index.</b> <br>

<p>We need to generate all the subsequences. We will use the pick/non-pick technique as discussed in, That we All Ready Learn in the Recursion Series.</p>
<b>We have two choices:</b>
<li>
    <b>Exclude the current element in the subsequence:</b> We first try to find a subsequence without considering the current index coin. If we exclude the current coin, the target sum will not be affected and the number of coins added to the solution will be <b>0</b>. So we will call the recursive function fun(ind-1,Target)
</li>
<li>
    <b>Include the current element in the subsequence:</b>  We will try to find a subsequence by considering the current ith coin. As we have included the coin, the target sum will be updated to T-arr[ind] and we have considered <b>1</b> coin to our solution.
</li>
<br>
<b>VVVV Important Point</b> <br>
<li><b>Now here is the catch, as there is an unlimited supply of coins, we want to again form a solution with the same coin value. So we will not recursively call for f(ind-1, T-arr[ind]) rather we will stay at that index only and call for f(ind, T-arr[ind]) to find the answer.</b></li>
<br>
<p>Note: We will consider the current coin only when its denomination value (arr[ind]) is less than or equal to the target Target.</p>
<br>
<img src="./Notes/L20refun3.jpg" alt=""> <br>

<b>Step 3: Return the maximum of take and notTake</b> <br>

<li>As we have to return the minimum number of coins, we will return the minimum of take and notTake as our answer.
</li>
<p>The final pseudocode after steps 1, 2, and 3:</p>
<br>
<img src="./Notes/L20refun4.jpg" alt="">
<b>Recursion Tree</b>
<img src="./Notes/L20rtree.jpg" alt=""> <br>


        <div class="container">
                    <div class="item">
                      <div class="title"><b>Recursion Python Code</b></div>
                      <div class="content">
                        <img src="./Notes/L20rcode (1).png" alt="" />
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion C++ Code</b></div>
                      <div class="content">
                        <img src="./Notes/L20rcode (2).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>
                  <br>

                  <h3>Time & Space Complexity</h3>
                  <b>Time Complexity: O(2^N)</b> <br>

Reason: Exponential Time we find out the all the Possible Path<br>

<b>Space Complexity: O(N)</b> <br>

Reason: We are using a recursion stack space(O(N))<br><br>

<h3>Memoization Approch</h3>


<p>
    If we observe in the recursion tree, we will observe a many number of overlapping subproblems. Therefore the recursive solution can be memoized for to reduce the time complexity.
</p>
<br>
<img src="./Notes/L20rtree.jpg" alt=""> <br>

<b>Steps to convert Recursive code to memoization solution:</b> <br><br>

<li>CCreate a dp array of size [n][T+1]. The size of the input array is ‘N’, so the index will always lie between ‘0’ and ‘n-1’. The target Sum can take any value between ‘0’ and ‘T’. Therefore we take the dp array as dp[n][T+1]</li> <br>
<li>We initialize the dp array to -1.</li> <br>
<li>Whenever we want to find the answer of particular parameters (say f(ind,T)), we first check whether the answer is already calculated using the dp array(i.e dp[ind][T]!= -1 ). If yes, simply return the value from the dp array.</li> <br>
<li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][target] to the solution we get.</li>
<br>




                  <div class="container">
                    <div class="item">
                      <div class="title"><b>Memoization Python Code</b></div>
                      <div class="content">
                        <img src="./Notes/L20memocode (1).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization C++ Code</b></div>
                      <div class="content">
                        <img src="./Notes/L20memocode (2).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>

                  <br>

                  <h3>Time & Space Complexity</h3>
                  
                    <b>Time Complexity:O(N*T)</b> <br>
                    
                    Reason: There are N*T states therefore at max ‘N*T’ new problems will be solved.<br>

<b>Space Complexity:  O(N*T) + O(N)</b> <br>

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*T)).<br><br>

<h3>Tabulation Approch</h3>

Tabulation is a <b>‘bottom-up’</b> approach where we start from the base case and reach the final answer that we want and Memoization is the <b>Top-down</b> Approch.
<br>
<p>
    In Tabulation Approch We Just Creat a DP Array Same as Memoization and Simply Convert the <b>Recurance Relation into the form of the Looping</b>
</p>

<b>Steps to convert Recursive Solution to Tabulation one.</b><br>

<li>To convert the memoization approach to a tabulation one, create a dp array with the same size as done in memoization. We can initialize it as 0.</li>
<br>
<li>First, we need to initialize the base conditions of the recursive solution.</li>
<br>
<li>At ind==0, we are considering the first element, if T%arr[0] ==0, we initialize it to T/arr[0] else we initialize it to 1e9.</li>
<br>
<li>
    Next, we are done for the first row, so our ‘ind’ variable will move from 1 to n-1, whereas our ‘target’ variable will move from 0 to ‘T’. We will set the nested loops to traverse the dp array.
</li>
<br>
<li>
    Inside the nested loops we will apply the recursive logic to find the answer of each cell.
</li><br>
<li>
    When the nested loop execution has ended, we will return dp[n-1][T] as our answer.
</li>
<br>

<div class="container">
  <div class="item">
    <div class="title"><b>Tabulation Python Code</b></div>
    <div class="content">
      <img src="./Notes/L20tabcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation C++ Code</b></div>
    <div class="content">
      <img src="./Notes/L20tabcode (2).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity:  O(N*T)</b> <br>

                    Reason:There are 2 nested loops<br>

<b>Space Complexity: O(N*T)</b> <br>

Reason: We are using an external array of size ‘N*T’. Stack Space is eliminated.<br><br>

<h3>Space Optimization</h3>

<p>
    If we closelly Observed <b>if any Tabulation Approch we used the Some Limited Stuff like: dp[ind][target] =  dp[ind-1][target] + dp[ind-1][target-arr[ind]]</b> for the finding the our ans then definetly here <b>Spaced Optimization</b> is Possible in that types of Problems. <b>Always Remember</b>
</p>

<b>Golden Rule</b>
<li>If we required only Prev row and Prev Collom then definetly we can Space Optimized</li>

<p>

  <li>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev). So, we don’t need to store an entire array. Hence we can space optimize it.</li> <br>

<div class="container">
  <div class="item">
    <div class="title"><b>SpaceOptmized Python Code</b></div>
    <div class="content">
      <img src="./Notes/L20spcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>SpaceOptmized C++ Code</b></div>
    <div class="content">
        <img src="./Notes/L20spcode (2).png" alt="" />
    </div>
  </div>
  

  <div class="item">
    <div class="title"><b>SpaceOptmized Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity: O(N*T)</b> <br>

                    Reason: There are three 2 nested loops<br>

<b>Space Complexity: O(T)</b> <br>

Reason: We are using two external arrays of size ‘T+1’.<br><br>

                </div>
                <br />

                <center>Happy Coding❤️</center>
              </div>
            </div>
          </div>
        </article>
        <!-- #post-## -->
      </main>

      <!-- #main -->
    </div>
    <script src="../script.js"></script>
  </body>
</html>
