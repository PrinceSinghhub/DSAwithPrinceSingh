<!DOCTYPE html>
<html lang="en-US" oncontextmenu="return false">
  <head>
    <title>DPL24 Rod Cutting</title>
    <link rel="icon" type="image/x-icon" href="../photo.jpg" />

    <link
      rel="stylesheet"
      id="wp-block-library-css"
      href="https://www.lexalytics.com/wp-includes/css/dist/block-library/style.min.css?ver=6.0.3"
      type="text/css"
      media="all"
    />
    <style id="global-styles-inline-css" type="text/css"></style>

    <link
      rel="stylesheet"
      id="wd_s-css"
      href="https://www.lexalytics.com/wp-content/themes/wd_s/build/index.css?ver=0c4cbca560ded1aeeb10beb9a609f609"
      type="text/css"
      media="all"
    />

    <link rel="stylesheet" href="../style.css" />
  </head>


  <body
    class="page-template-default page page-id-2597 page-child parent-pageid-2342 wp-embed-responsive site-wrapper page-machine-learning group-blog no-js"
  >
    <a class="skip-link screen-reader-text" href="#main">Skip to content</a>

    <div class="site-main">
      <main id="main" class="content-container">
        <article
          id="post-2597"
          class="post-2597 page type-page status-publish hentry"
        >
          <div class="entry-content">
            <div
              id="section-block_627ed6b337646"
              class="block-section relative overflow-hidden 0"
            >
              <div class="bg-white py-100 bg-cover centerbg- bg-no-repeat">
                <div class="relative container-narrow">
                  <h5 class="has-text-align-center">
                    <mark
                      style="background-color: rgba(0, 0, 0, 0)"
                      class="has-inline-color has-nebula-color"
                    >
                      JB TAK FODEGA NHI .... TB TK CHODEGA NHI .... (MAANG)
                    </mark>

                    <br><br>

                    <div class="dsa">
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh1/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://leetcode.com/PrinceSingh2/"><img src="../dsaProfileImg/lc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://auth.geeksforgeeks.org/user/itsprince/practice"><img src="../dsaProfileImg/gfg.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codingninjas.com/codestudio/profile/b7191958-3dea-4d59-a909-70a6bd5400c8"><img src="../dsaProfileImg/cn.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.interviewbit.com/profile/princesingh2002"><img src="../dsaProfileImg/ib.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerrank.com/dsawithprince?hr_r=1"><img src="../dsaProfileImg/hr.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.hackerearth.com/@prince1033"><img src="../dsaProfileImg/he.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.codechef.com/users/princesingh001"><img src="../dsaProfileImg/cc.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://codeforces.com/profile/thisisPrinceSingh"><img src="../dsaProfileImg/cf.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://workat.tech/profile/itsprincesingh"><img src="../dsaProfileImg/wk.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://www.linkedin.com/in/prince-singh-314a65187/"><img src="../dsaProfileImg/lin.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://github.com/PrinceSinghhub"><img src="../dsaProfileImg/gh.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://twitter.com/NowPrinceSingh"><img src="../dsaProfileImg/tw.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://stackoverflow.com/users/16512708/prince-singh"><img src="../dsaProfileImg/st.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://topmate.io/itsprincesingh"><img src="../dsaProfileImg/topm.png" alt=""></a></div>
                      <div class="dsaProfile"><a href="https://hashnode.com/@itsPrinceSingh"><img src="../dsaProfileImg/hn.png" alt=""></a></div>
                    </div>
                  </h5>

                  <h1 class="has-text-align-center mb-60">
                    DPL24 Rod Cutting
                  </h1>

                  <div class="allBTNGroups">
                  <!-- <button class="hardQst" role="button">üò¢ Hard</button> -->
                  <button class="mediumQst" role="button">üòü Medium</button>
                  <!-- <button class="easyQst" role="button">üòä Easy</button>
                    
                    <button class="hardQst" role="button">üò¢ Hard</button> -->
                  <a href=""><button class="leetcodelink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/leetcode.webp" alt="">LeetCode
                      </div>
                    </button></a>
                  <a href=""><button class="gfgQstlink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/geeksforgeeks.png" alt="">GeeksForGeeks
                      </div>
                    </button></a>
                  <a href=""><button class="codslink" role="button">
                      <div class="imgQstDiv">
                        <img src="../dsaProfileImg/codeStudio.png" alt="">CodeStudio
                      </div>
                    </button></a>
                </div>

                  <!-- Problem Statements  -->
                  <p>We are given a rod of size ‚ÄòN‚Äô. It can be cut into pieces. Each length of a piece has a particular <b>price</b> given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.</p>

                 <img src="./Notes/L24expImg.jpg" alt=""> <br>

                 <p>Bacially this Problem is the <b>Observation Based</b> Problem Same like <b>DPL23 Unbounded Knapsack & infinite Supply</b> Jut we need to Identify the Pattern, Only need to Indetify the <B>maxWeight or W (Knapsack Capicity)</B> Becouse in this Problem We Have Not Given the Directily W of the Knapsack, We Need to Identify the W and <b>Remaing Thing will be Same as like in DPL23</b></p>
                 <br>

                 <img src="./Notes/L24expImg1.jpg" alt="">
                 <br>

                 <B>maxWeight or W (Knapsack Capicity) ?</B>
                 <li>In Both Problems <b>DPL19 & DPL23</b> We have Given a W (Knapsack Capicity), but in this Problem we have not a W (Knapsack Capicity), So what we Do?</li>
                 <li>Now here we used the <b>len(price)</b> that we given, used as a <b>W (Knapsack Capicity)</b> and we go with same code and logic with <b>DPL23</b></li>

                 <br>
                 <b><h5>Now Remaining Entire üëá Process will Be Same As Like in DPL23</h5></b> <br>


                 <li>In <b>DPL19</b> We Try to Find Out the Maximum Profit Under the Given Knapsack Bag Weight and we used the <b>Items at only One Time</b></li>
                 <li>In this Problem We Try to Find Out the Maximum Profit But <b>This Problem Based on the infinite Supply Same Like We Do in DPL20 and DPL22 </b>and<b> We can take a single item any number of times he wants and put it in his knapsack.</b></li>
                 <li>That is the Only Difference in Both Problem, Just we Re-Write the Base Case and</li> <br>
                 

                  <b>This Quesion Again Based on the DPL19 Not Same but We Used the Concept of the Take and notTake Same As in DPL19 only Base Condition Will be Changed</b> <br><br>

                  <b>Why a Greedy Solution doesn‚Äôt work?</b>
                  <p>The first approach that comes to our mind is greedy. A greedy solution will fail in this problem because there is no <b>‚Äòuniformity‚Äô</b> in data. While selecting a local better choice we may choose an item that will in long term give less value.</p>

                  <b>Let us understand this with help of an example</b>

                  <center><img src="./Notes/L19grImg.jpg" alt="" style="width: 300px;"></center>

                  <li>A Greedy solution will be to take the most valuable item first, so we will take an item on index 2, with a value of 60, and put it in the knapsack. Now the remaining capacity of the knapsack will be 1. Therefore we cannot add any other item. So a greedy solution gives us the answer 60.</li> <br>
                  <li>Now we can clearly see that a non-greedy solution of taking the first two items will give us the value of 70 (30+40) in the given capacity of the knapsack.</li> <br>

             
                 
                  <h3>Recursice Approch</h3>

                  <b>Steps to form the Recursive Solution</b> <br>

                  <b>Step 1: Express the problem in terms of indexes.</b><br>

<li>
    We are given ‚Äòn‚Äô items. Their weight is represented by the ‚Äòwt‚Äô array and value by the ‚Äòval‚Äô array. So clearly one parameter will be ‚Äòind‚Äô, i.e index up to which the array items are being considered.<br>

    There is one more parameter ‚ÄúW‚Äù. We need the capacity of the knapsack to decide whether we can pick an array item or not in the knapsack. <br>

    So, we can say that initially, we need to find fun(n-1, W) where W is the overall capacity given to us. fun(n-1, W) means we are finding the maximum value of items that the thief can steal from items with index 0 to n-1 capacity W of the knapsack.
</li> <br>

<img src="./Notes/L19rImg1.jpg" alt=""> <br>

<b>Our Base Case</b>
<li>If ind==0, it means we are at the first item. Now, in an Rod Cutting we can pick an item any number of times we want. As there is only one item left, we will pick for <b>W/weight[0]</b> times because we ultimately want to maximize the value of items while respecting the constraint of weight of the knapsack. The value added will be the product of the number of items picked and value of the individual item. Therefore we return <b>(W/weight[0]) * val[0].</b>
</li> <br>

<img src="./Notes/L23refun1.jpg" alt="">

<br>
<b>Step 2: Try out all possible choices at a given index.</b> <br>

<p>We need to generate all the subsequences. We will use the pick/non-pick technique as discussed in, That we All Ready Learn in the Recursion Series.</p>
<b>We have two choices:</b>
<li>
    <b>Exclude the current element in the subsequence:</b> We first try to find a subsequence without considering the current index item. If we exclude the current item, the capacity of the bag will not be affected and the value added will be 0 for the current item. So we will call the recursive function f(ind-1,W)
</li>
<li>
    <b>Include the current element in the subsequence:</b> We will try to find a subsequence by considering the current item to the knapsack. As we have included the item, the capacity of the knapsack will be updated to W-wt[ind] and the current item‚Äôs value val[ind] will also be added to the further recursive call answer. We will make a recursive call to f(ind-1, W- wt[ind]).
</li>
<br>
<b>VVVV Important Point</b> <br />
                  <li>
                    <b
                      >Now here is the catch, as there is an unlimited supply of
                      coins, we want to again form a solution with the same coin
                      value. So we will not recursively call for fun(ind-1,
                      Target-arr[ind]) rather we will stay at that index only and
                      call for fun(ind, Target-arr[ind]) to find the answer.</b
                    >
                  </li>
                  <br />
                  <p>
                    Note: We will consider the current item in the subsequence only when the current element‚Äôs weight is less than or equal to the capacity ‚ÄòW‚Äô of the knapsack, if it isn‚Äôt we will not be considering it.
                  </p>
<br>
<img src="./Notes/L23refun2.jpg" alt=""> <br>

<b>Step 3: Return the maximum of take and notTake</b> <br>

<li>As we have to return the maximum amount of value, we will return the max of take and notTake as our answer.
</li>
<p>The final pseudocode after steps 1, 2, and 3:</p>
<br>
<img src="./Notes/L23refun3.jpg" alt=""> <br>


        <div class="container">
                    <div class="item">
                      <div class="title"><b>Recursion Python Code</b></div>
                      <div class="content">
                        <img src="./Notes/L24rcode (1).png" alt="" />
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion C++ Code</b></div>
                      <div class="content">
                        <img src="./Notes/L24rcode (2).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Recursion Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>
                  <br>

                  <h3>Time & Space Complexity</h3>
                  <b>Time Complexity: O(2^N)</b> <br>

Reason: Exponential Time we find out the all the Possible Path<br>

<b>Space Complexity: O(N)</b> <br>

Reason: We are using a recursion stack space(O(N))<br><br>

<h3>Memoization Approch</h3>

<p>
    If we observe in the recursion tree, we will observe a many number of overlapping subproblems. Therefore the recursive solution can be memoized for to reduce the time complexity.
</p>

<b>Steps to convert Recursive code to memoization solution:</b> <br><br>

<li>Create a dp array of size [n][W+1]. The size of the input array is ‚ÄòN‚Äô, so the index will always lie between ‚Äò0‚Äô and ‚Äòn-1‚Äô. The capacity can take any value between ‚Äò0‚Äô and ‚ÄòW‚Äô. Therefore we take the dp array as dp[n][W+1]</li> <br>
<li>We initialize the dp array to -1.</li> <br>
<li>Whenever we want to find the answer of particular parameters (say f(ind,target)), we first check whether the answer is already calculated using the dp array(i.e dp[ind][target]!= -1 ). If yes, simply return the value from the dp array.</li> <br>
<li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][target] to the solution we get.</li>
<br>




                  <div class="container">
                    <div class="item">
                      <div class="title"><b>Memoization Python Code</b></div>
                      <div class="content">
                        <img src="./Notes/L24memocode (1).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization C++ Code</b></div>
                      <div class="content">
                        <img src="./Notes/L24memocode (2).png" alt="">
                      </div>
                    </div>

                    <div class="item">
                      <div class="title"><b>Memoization Java Code</b></div>
                      <div class="content">
                        <h5>Sb Mai He Kru ...</h5>
                        <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
                      </div>
                    </div>
                  </div>

                  <br>

                  <h3>Time & Space Complexity</h3>
                  
                    <b>Time Complexity:O(N*W)</b> <br>
                    
                    Reason: There are N*W states therefore at max ‚ÄòN*W‚Äô new problems will be solved.<br>

<b>Space Complexity:  O(N*W) + O(N)</b> <br>

Reason: We are using a recursion stack space(O(N)) and a 2D array ( O(N*W)).<br><br>

<h3>Tabulation Approch</h3>

Tabulation is a <b>‚Äòbottom-up‚Äô</b> approach where we start from the base case and reach the final answer that we want and Memoization is the <b>Top-down</b> Approch.
<br>
<p>
    In Tabulation Approch We Just Creat a DP Array Same as Memoization and Simply Convert the <b>Recurance Relation into the form of the Looping</b>
</p>

<b>Steps to convert Recursive Solution to Tabulation one.</b><br>

<li>To convert the memoization approach to a tabulation one, create a dp array with the same size as done in memoization. We can initialize it as 0.</li>
<br>
<li>First, we need to initialize the base conditions of the recursive solution.</li>
<br>
<li>At ind==0, we are considering the first element, if the capacity of the knapsack is greater than the weight of the first item, we return val[0] as answer. We will achieve this using a for loop.</li>
<br>
<li>
    At ind==0, we are considering the first element, so we will assign its value as <b>(i/wt[0]) * val[0]</b>, where i will iterate from 0 to W.
</li>
<br>
<li>
    Next, we are done for the first row, so our ‚Äòind‚Äô variable will move from 1 to n-1, whereas our ‚Äòcap‚Äô variable will move from 0 to ‚ÄòW‚Äô. We will set the nested loops to traverse the dp array.
</li><br>
<li>
    Inside the nested loops we will apply the recursive logic to find the answer of the cell.
</li>
<br>
<li>When the nested loop execution has ended, we will return dp[n-1][W] as our answer.</li><br>
<div class="container">
  <div class="item">
    <div class="title"><b>Tabulation Python Code</b></div>
    <div class="content">
      <img src="./Notes/L24tabcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation C++ Code</b></div>
    <div class="content">
      <img src="./Notes/L24tabcode (2).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Tabulation Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity:  O(N*W)</b> <br>

                    Reason:There are 2 nested loops<br>

<b>Space Complexity: O(N*K)</b> <br>

Reason: We are using an external array of size ‚ÄòN*W‚Äô. Stack Space is eliminated.<br><br>

<h3>Space Optimization</h3>

<p>
    If we closelly Observed <b>if any Tabulation Approch we used the Some Limited Stuff like: dp[ind][cap] =  max(dp[ind-1][cap] ,dp[ind-1][cap-wt[ind]])</b> for the finding the our ans then definetly here <b>Spaced Optimization</b> is Possible in that types of Problems. <b>Always Remember</b>
</p>

<b>Golden Rule</b>
<li>If we required only Prev row and Prev Collom then definetly we can Space Optimized</li> <br>
<b>Every Steps are Same That We Follow in the DPL19 No Need to Change Anything in these Steps, Only Chnage the Recurance Relation and Convert into the loop, and Remaing Things Will be Same.</b>

<p>

  <li>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev). So, we don‚Äôt need to store an entire array. Hence we can space optimize it.</li> <br>

  <li>We will be space optimizing this solution using <b>only one row</b>.</li> <br>

    <li>If we closely observe, we fill in the following manner in two-row space optimization</li><br>
    <li>We will  initialize the first row and then using its values we will the next row.</li> <br>
    <center><img src="./Notes/L19spImg1.jpg" alt="" style="width: 400px;"></center> <br>
    <li>If we clearly see the values required:  dp[ind-1][cap] and dp[ind-1][cap ‚Äì wt[ind]], we can say that if we are at a column cap, we will only require the values shown in the green region and none in the red region shown in the below image ( because cap ‚Äì wt[ind] will always be less than the cap).</li> <br>
    <center><img src="./Notes/L19spImg2.jpg" alt="" style="width: 400px;"></center> <br>
    <li>As we don‚Äôt want values from the right, we can start filling this new row from the right rather than the left.</li> <br>
    <center><img src="./Notes/L19spImg3.jpg" alt="" style="width: 400px;"></center> <br>
    <li>Now here is the catch, if we are filling from the right and at any time we need the previous row‚Äôs value of the leftward columns only, why do we need to have two rows in the first place? We can use a single row and <b>overwrite</b> the new computed values on itself in order to store it.</li>
</p> <br>

<b>Single Row Space Optimization Approch</b>
<center><img src="./Notes/L19spImg4.jpg" alt="" style="width: 400px;"></center> <br>
<br>
<div class="container">
  <div class="item">
    <div class="title"><b>SpaceOptmized Python Code</b></div>
    <div class="content">
      <img src="./Notes/L24spcode (1).png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>Most Optimial Python Code üî•</b></div>
    <div class="content">
      <img src="./Notes/L24motCode.png" alt="" />
    </div>
  </div>

  <div class="item">
    <div class="title"><b>SpaceOptmized C++ Code</b></div>
    <div class="content">
        <img src="./Notes/L24spcode (2).png" alt="" />
    </div>
  </div>
  

  <div class="item">
    <div class="title"><b>SpaceOptmized Java Code</b></div>
    <div class="content">
      <h5>Sb Mai He Kru ...</h5>
      <p>Khud Bhi Kr le Khuch ..... Nalayk</p>
    </div>
  </div>
</div>

<br>

<h3>Time & Space Complexity</h3>
                    <b>Time Complexity: O(N*W)</b> <br>

                    Reason: There are three 2 nested loops<br>

<b>Space Complexity: O(W)</b> <br>

Reason: We are using an external array of size ‚ÄòW+1‚Äô to store only one row.<br><br>

                </div>
                <br />

                <center>~ It's All About Consistencyüìà DedicationüéØ HardWorküí™ Happy Coding‚ù§Ô∏è ~</center>
              </div>
            </div>
          </div>
        </article>
        <!-- #post-## -->
      </main>

      <!-- #main -->
    </div>
    <script src="../script.js"></script>
  </body>
</html>
